# Практика gRPC

Надеюсь, на семинаре мы смогли объяснить, почему иногда gRPC бывает полезен. В этой задаче вы потрогаете технологию руками, чтобы в будущем не возникало неопределенности при разговоре "Давайте воспользуемся тут gRPC".

## Мессенджер с одним чатом
В рамках практики предлагается реализовать очень простые сервер и клиент мессенджера. У сервера есть всего один чатрум, к которому мы хотим подключаться через server-side streaming и читать сообщения из него на клиенте. Вторая необходимая фича — уметь отправлять сообщения в этот чат. Таким образом у сервера будет всего два RPC-метода.

Клиент, соответственно, должен при включении открыть поток и скапливать в своём буфере пришедшие сообщения. Кроме того, через клиент мы должны уметь отправлять сообщения в чат.

### Интерфейс взаимодействия с клиентом

В папке задания предоставлены заготовки клиентов на языках Python и Golang для решения этой задачи. Можно писать на любом другом языке, тесты отправляют запросы клиенту, который представляет собой HTTP сервер, поддерживающий два вида запросов:

```
POST /sendMessage
Отправляет одно сообщение в общий чат.
Body:
{
    "author": "Ivan Ivanov",
    "text": "Hey guys"
}

Response:
{
    "sendTime": "..."
}

POST /getAndFlushMessages
Возвращает буферизированные сообщения, удаляя их из буфера.
Response:
[{
    "author": "Ivan Ivanov",
    "text": "Hey guys",
    "sendTime": "..."
},{
    "author": "Petr Petrov",
    "text": "Hey Ivan",
    "sendTime": "..."
}]
```

Примеры с curl:
```
$ curl -X POST localhost:8080/sendMessage -d '{"author": "Ivan", "text": "hey"}'
{"sendTime":"2021-09-12T10:25:22.454093428Z","error":null}


$ curl -X POST localhost:8080/getAndFlushMessages
[{"author":"Ivan","text":"hey","sendTime":"2021-09-12T10:25:22.454093428Z"},{"author":"Ivan","text":"hey guys","sendTime":"2021-09-12T10:25:41.296997047Z"}]
```

### Необходимые детали реализации

1. Клиент должен принимать описанные выше HTTP-запросы для того, чтобы тесты могли пройти
2. В docker-compose файле используются некоторые переменные окружения для настройки сервера и клиентов, их необходимо поддержать в вашем приложении (они есть в заготовках клиентов, но заготовок для сервера нет):
   - у вашего сервера должна быть переменная `MESSENGER_SERVER_PORT`, по умолчанию равная `51075`, которая указывает, на каком порте запустить gRPC сервер
   - `MESSENGER_SERVER_ADDR` — адрес gRPC сервера для клиента, чтобы подключиться к серверу, есть в заготовке
   - `MESSENGER_HTTP_PORT` — порт для запуска HTTP-сервера вашего клиента, есть в заготовке
3. Клиент должен открывать поток сообщений на чтение сразу после запуска.

### Компоненты задания
1. **(2 балла)** Описать gRPC интерфейс сервера в `messenger.proto`
2. **(4 балла)** Реализовать gRPC сервер мессенджера
3. **(4 балла)** Реализовать gRPC клиент и встроить его в HTTP-приложение клиента.
4. README в папке с решением с описанием структуры решения (где какой код лежит), какие именно методы реализованы на сервере и клиенте, как они устроены в паре предложений. Обязательно укажите, какие компоненты были выполнены, 

При отсутствии README проверка производиться не будет. Тесты реализованы только на HTTP клиент, поэтому при частичном решении в README необходимо дополнительно отразить, какие именно части сделаны, так как оценка будет проводиться исходя из написанного вами README.

### В каком порядке делать?
1. Напишите свой `messenger.proto` в `messenger/grpc/` и скомпилируйте его с помощью `protoc` в нужный для вас язык
2. Реализуйте сервер, соответствующий сгенерированному интерфейсу, его можно проверять с помощью [grpcurl](https://github.com/fullstorydev/grpcurl), пример можно найти в документации или в семинаре. Заготовки для сервера нет, поэтому его надо реализовать с нуля, используя gRPC Basics Tutorial для вашего языка программирования.
3. Напишите `messenger/server.dockerfile` для вашего сервера, чтобы его можно было запустить при тестировании  
4. Реализуйте клиент, который осуществляет gRPC-вызовы и соответствующим образом обрабатывает результат. В заготовках эти места указаны с помощью TODO, хотя принимается любая реализация, которая проходит тесты и использует ваш gRPC сервер.
5. Поправьте или напишите свой `messenger/client.dockerfile` для вашего клиента, чтобы его можно было запустить при тестировании.
6. Проверьте локально, что ваши тесты проходят, лучше сразу в [докере](#docker). Если `docker-compose` на что-то ругается, то поправьте конфигурацию как вам необходимо.
7. Откройте Merge Request в своём приватном репозитории и дождитесь, что тесты зелёные

## Запуск заготовок и тестов
### Локально

Заготовки сервера нет, поэтому пишите на любом языке. Главное, чтобы сервер реализовывал ваш gRPC интерфейс и поддерживал переопределение порта с помощью переменной `MESSENGER_SERVER_PORT`. Полный адрес должен быть `0.0.0.0:$MESSENGER_SERVER_PORT`.

Заготовка клиента на python:
```
cd messenger/client-py
python3 -m virtualenv env  # нужен python версии хотя бы 3.8
source env/bin/activate
pip install -r requirements.txt

MESSENGER_SERVER_ADDR=localhost:$MESSENGER_SERVER_PORT python client.py 
```

Заготовка клиента на golang:
```
cd messenger/client-go
go mod download -x

MESSENGER_SERVER_ADDR=localhost:$MESSENGER_SERVER_PORT go run main.go
```

Запуск тестов:
```
cd tests
# можно использовать общее окружение с вашим клиентом и сервером, тогда положите его в корень папки с заданием
python3 -m virtualenv env  # нужен python версии хотя бы 3.8
source env/bin/activate
pip install -r requirements.txt

MESSENGER_TEST_CLIENT1_ADDR=localhost:8080 MESSENGER_TEST_CLIENT2_ADDR=localhost:8081 pytest -vvs .
```

### Docker
Соберите все свои сервисы:
```
docker-compose build server client1 client2
```

При изменении одного из них достаточно пересобрать только его:
```
docker-compose build server
```

client1 и client2 используют один и тот же образ для запуска, поэтому при изменении сервера можно пересобрать только одного из них:
```
docker-compose build client1
```

Запустите сервер и клиентов:
```
docker-compose up -d server client1 client2
```

Сборка и запуск тестов:
```
docker-compose build tests
docker-compose run --rm tests
```
