# Group Membership

В этой задаче вам предстоит реализовать распределенный сервис для отслеживания состава группы (group membership).

Пусть имеется распределенная система, состоящая из _N_ узлов. У каждого узла есть свой уникальный идентификатор. Будем говорить, что все работающие в некоторый момент узлы системы образуют _группу_, то есть являются ее участниками. В ходе работы системы узлы могут включаться и выключаться, тем самым вступая в группу или покидая её. Таким образом, состав участников группы может изменяться со временем. Сервис, который вам надо реализовать, должен позволять узлам узнавать текущий состав группы, а также выполнять вход и выход из группы.

Помимо явного выхода из группы (например, при штатном выключении), узлы могут покидать группу из-за отказов. В нашей модели системы возможны следующие виды отказов:
- Внезапная остановка (падение) узла. Позднее узел может быть перезапущен (с тем же id) и заново подключен к группе. Работающий узел будем называть живым.
- Потеря сообщений между некоторыми парами узлов, в обоих или только в одном направлении. В результате живые узлы могут отказаться полностью или частично отрезаны от других узлов. Отказы сети могут носить временный характер, после чего связь восстанавливается.

Ваша реализация должна обнаруживать описанные выше отказы и обрабатывать их. Для этого вам потребуется реализовать _детектор отказов_. Ваш детектор должен обладать свойством _полноты_ - если узел стал недоступным из-за отказа, то в конечном счете все участники группы признают его отказавшим. Также постарайтесь найти хороший баланс между скоростью обнаружения отказов, точностью детектора и сопутствующими накладными расходами.

Упавшие или недоступные ни с одного из остальных участников группы узлы должны автоматически исключаться из состава группы. Таким образом, в состав группы должны входить только живые узлы, способные общаться по сети (в обе стороны) с хотя бы одним другим участником группы. Вам не требуется обеспечивать строгую согласованность списков участников между узлами. Иными словами, допустимо, если в некоторый момент времени списки участников группы на разных узлах отличаются (например, отказавший узел кое-где еще выдается как участник группы). Главное чтобы через некоторое время после отказа или входа/выхода участника состав группы стабилизировался и стал одинаковым на всех её текущих участниках. Это называется согласованностью в конечном счёте (eventual consistency).

Из-за сетевых отказов система может распасться на несколько изолированных подгрупп. Такая ситуация называется разделением сети (network partition). Простейшим частным случаем разделения является отключение от сети одного узла. Разделение может быть асимметричным, когда связь между частями системы отсутствует только в одну сторону. Ваша реализация должна уметь работать в условиях разделения сети, позволяя каждому живому узлу отлеживать состав участников в его подгруппе. Например, если узел оказался отключен от сети, то он будет видеть в участниках группы только себя, а остальные узлы будут видеть в группе всех кроме него. Когда сеть восстанавливается, то в конечном счёте все узлы должны увидеть всех в участниках группы.

Дополнительно (на 10 баллов) требуется обеспечить хорошую масштабируемость полученного решения. А именно, при увеличении числа узлов в _X_ раз накладные расходы (сетевой трафик и число передаваемых сообщений) должны увеличиваться не более чем в _2X_ раз. Кроме того, нагрузка на узлы (в плане числа обрабатываемых сообщений) должна распределяться равномерно - отношение max/min нагрузки по всем узлам не должно превышать 5.

## Реализация

Для реализации и тестирования решения используется фреймворк dslib, см. материалы первого семинара.

В папке задачи размещена заготовка для решения [solution.py](solution.py). Вам надо доработать реализацию узла в классе `GroupMember` так, чтобы проходили все тесты.

При инициализации узлу передается его уникальный id. Узел должен поддерживать обработку следующих локальных сообщений:
- _JOIN_ - команда присоединиться к группе. В результате обработки этой команды узел должен стать участником группы. В поле `seed` передается идентификатор одного из живых участников группы. Если в `seed` находится идентификатор самого узла, то он должен создать новую пустую группу и добавить в неё себя. Ответ на это сообщение не нужен.
- _LEAVE_ - команда покинуть группу. В результате обработки этой команды узел должен перестать быть участником группы. Ответ на это сообщение не нужен.
- _GET_MEMBERS_ - запрос списка участников группы. В ответ на запрос узел должен отправить локальное сообщение _MEMBERS_ со списком идентификаторов узлов, входящих сейчас в группу (см. заготовку).

Для взаимодействия между узлами вы можете использовать любые собственные типы сообщений.

**Важно!** Для измерения прошедшего времени в коде узла используйте метод `ctx.time()`, возвращающий время в секундах с начала выполнения системы "внутри симуляции". Использовать обычные способы, например `time.time()`, некорректно, так как скорость течения времени в симуляции отличается от реального времени.

В коде узла можно использовать генератор случайных чисел из `random`, но не следует его явно инициализировать с помощью `random.seed()`. Это уже делается в dslib на основе переданного в тесты seed, а дополнительная инициализация может нарушить воспроизводимость результатов.

## Тестирование

Перед запуском тестов убедитесь, что на вашей машине [установлен Rust](https://www.rust-lang.org/tools/install) (версия не ниже 1.53), а рядом с папкой задачи есть папка `dslib`.

Тесты находятся в папке `test`. Для запуска тестов перейдите в эту папку и выполните команду: `cargo run --release`. Запустить только один из тестов можно с помощью опции `-t`. По умолчанию вывод тестов не содержит трассы (последовательности событий во время выполнения каждого из тестов), а только финальную сводку. Включить вывод трасс можно с помощью флага `-d`. Все доступные опции можно посмотреть с помощью `cargo run --release -- --help`.

Также можно воспользоваться подготовленным [Docker-образом](Dockerfile) (в нём же тесты запускаются в GitLab CI). Работа с образом полностью аналогична тому, как это описано в первой задаче.

Если вы найдете ошибки или требования из условий, которые не покрывают наши тесты, то вы можете получить за это бонусы. Для этого надо включить в отчёт описание ситуации, которую не ловят тесты, добавив при необходимости пример решения с ошибкой. За это полагается 0.5 балла. Если вы также реализуете тесты, которые ловят найденную проблему, или хотя бы опишите их логику, то получите еще 0.5 балла. Готовые тесты оформляйте как merge request в родительский репозиторий с заданиями.

## Сдача

Следуйте стандартному [порядку сдачи заданий](../README.md). Отчёт разместите в файле `report.md` рядом с решением.

## Оценивание

Компоненты задачи и их вклад в оценку:
- Базовый функционал без обработки отказов (тесты: SIMPLE, RANDOM SEED, NODE JOIN, NODE LEAVE) - 4 балла
- Обработка отказов узлов (тесты "NODE CRASH" в названии) - 2 балла
- Обработка отказов сети (остальные тесты кроме "SCALABILITY...") - 2 балла
- Масштабируемость при росте числа узлов (тесты "SCALABILITY...") - 2 балла
- Краткое описание вашего решения в файле `solution.md` - обязательно, без него проверка производиться не будет.